.org 0x200
data1:.DB 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R'
.org 0x300
data2:.DB 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
.org 0x100
MSG:.DB "KYLE ",0

.ORG 0X00
JMP START
.ORG 0X02
JMP INT0ROUTINE

INT0ROUTINE:	
	//TODO: CHECK IF BUTTON 19 IS PRESSED, SET SHIFT_ENABLED = 1
	CALL CLEAR_SCREEN
	CALL DELAY_2MS
	CALL DELAY_2MS
	CALL DELAY_2MS
	CALL DELAY_2MS
	CALL DELAY_2MS
	CALL DELAY_2MS
	CALL DELAY_2MS
	CALL DELAY_2MS
	CALL DELAY_2MS
	CALL DELAY_2MS
	CALL DELAY_2MS
	//CALL WriteWord    //TODO: WRITE A SHIFT REGISTER TO STORE 4 LETTERS, AND SEND IT OUT AS A WORD
	CALL LOAD_KEYPAD
	CALL LOADZREGISTER1 //TODO: IF SHIFT_ENABLED THEN LOADZREGISTER2 INSTEAD
	CALL LOAD_KEYPAD
	CALL LOADZREGISTER1 //TODO: IF SHIFT_ENABLED THEN LOADZREGISTER2 INSTEAD
	CALL DATAWRT
RETI

MAIN:
	RJMP MAIN ; WE CAN STILL BE INTERRUPTED, BUT WE WILL RETURN HERE

CLEAR_SCREEN:
	LDI R16,0b00000001
	CALL CMNDWRT
RET

WriteWord: 
	LDI R31,HIGH(MSG<<1)
	LDI R30,LOW(MSG<<1);
	WRITEWORDLOOP:
		LPM R16,Z+
		CPI R16,0
		BREQ MAIN
		CALL DATAWRT
	RJMP WRITEWORDLOOP
RET

LOAD_KEYPAD:
	LDI R16,0X00
	OUT KPD_DDR,R16
	NOP
	IN R16,KPD_PIN
RET
	;STS MYTEMP,R16

LoadZRegister1:
	ldi ZL, low(2*data1)
	ldi ZH, high(2*data1)
	add zl,r16 ; add the BCD  value to be converted to low byte of 7SEG CODE TABLE to create an offset numerically equivalent to BCD value 
	lpm r16,z ; load z into r17 from program memory from7SEG CODE TABLE using modified z register as pointer
ret

LoadZRegister2:
	ldi ZL, low(2*data2)
	ldi ZH, high(2*data2)
	add zl,r16 ; add the BCD  value to be converted to low byte of 7SEG CODE TABLE to create an offset numerically equivalent to BCD value 
	lpm r16,z ; load z into r17 from program memory from7SEG CODE TABLE using modified z register as pointer
ret

START:
INITIALIZE_SHIFT_BUTTON:
	.EQU SHIFT_ENABLED = 0

INITIALIZE_KEYPAD_INPUT:
	.EQU KPD_PRT = PORTC
	.EQU KPD_DDR = DDRC
	.EQU KPD_PIN = PINC
    LDI R16, 0x00 ; load 0's into R16
	OUT KPD_DDR, R16 ; output 1's to configure DDRc as "input" port
	OUT KPD_PRT, R16 ; output 1's to configure DDRc as "input" port

CONFIGURE_INTERRUPTS:
	LDI R31,0X0A
	STS EICRA,R31
	LDI R31,0X03
	OUT EIMSK,R31
	LDI R31,0X00
	OUT DDRD,R31
	LDI R31,0X0C
	OUT PORTD,R31
	SEI

CONFIGURE_LCD:
	.EQU LCD_PRT = PORTB
	.EQU LCD_DDR = DDRB
	.EQU LCD_PIN = PINB
	.EQU LCD_RS = 0
	.EQU LCD_RW = 1
	.EQU LCD_EN = 2

INITIALIZE_STACK:
	LDI R21,HIGH(RAMEND)
	OUT SPH,R21 ; SET UP STACK
	LDI R21,LOW(RAMEND)
	OUT SPL,R21


INITIALIZE_LCD:
	LDI r21,0xFF;
	OUT LCD_DDR,R21
	OUT LCD_DDR,R21
	LDI R16,0X33
	CALL CMNDWRT
	CALL DELAY_2ms
	LDI R16,0X32
	CALL CMNDWRT
	CALL DELAY_2ms
	LDI R16,0X28
	CALL CMNDWRT
	CALL DELAY_2ms
	LDI R16,0X0E
	CALL CMNDWRT
	LDI R16,0X01
	CALL CMNDWRT
	CALL DELAY_2ms
	LDI R16,0X06
	CALL CMNDWRT
	
	CALL WriteWord

JMP MAIN ; WE CAN STILL BE INTERRUPTED, BUT WE WILL RETURN HERE


CMnDWRT:
	MOV R27,R16
	ANDI R27,0XF0  
	IN R26,LCD_PRT
	ANDI R26,0X0F
	OR R26,R27
	OUT Lcd_PRT,R26
	CBI LCD_PRT,LCD_RS
	CBI LCD_PRT,LCD_RW
	SBI LCD_PRT,LCD_EN
	CALL SDELAY
	CBI LCD_PRT,LCD_EN

	CALL DELAY_100us

	MOV R27,R16
	SWAP R27
	ANDI R27,0XF0
	IN R26,LCD_PRT
	ANDI R26,0X0F
	OR R26,R27
	OUT LCD_PRT,R26
	SBI LCD_PRT,LCD_EN
	CALL SDELAY
	CBI LCD_PRT,LCD_EN

	CALL DELAY_100us
RET


DATAWRT:
	MOV R27,R16
	ANDI R27,0XF0
	IN R26,LCD_PRT
	ANDI R26,0X0F
	OR R26,R27
	OUT Lcd_PRT,R26
	SBI LCD_PRT,LCD_RS
	CBI LCD_PRT,LCD_RW
	SBI LCD_PRT,LCD_EN
	CALL SDELAY
	CBI LCD_PRT,LCD_EN

	MOV R27,R16
	SWAP R27
	ANDI R27,0XF0
	IN R26,LCD_PRT
	ANDI R26,0X0F
	OR R26,R27
	OUT Lcd_PRT,R26
	SBI LCD_PRT,LCD_EN
	CALL SDELAY 
	CBI LCD_PRT,LCD_EN

	CALL DELAY_100us
RET

SDELAY:
	NOP ; NO OPERATION, JUST TAKES UP 1 CLOCK CYCLE
	NOP ; NO OPERATION, JUST TAKES UP 1 CLOCK CYCLE
RET

DELAY_100us: ; DELAY 100 MICRO SECONDS
	PUSH R17
	LDI R17,60

DR0: 
	CALL SDELAY  
	DEC R17
	BRNE DR0  ; LOOP THIS 60 TIMES
	POP R17
RET


DELAY_2ms: ; DELAY 2 MILLI SECONDS
	PUSH R17
	LDI R17,20

LDR0: 
	CALL DELAY_100us   
	DEC R17  
	BRNE LDR0   ; LOOP THIS 20 TIMES
	POP R17
RET
